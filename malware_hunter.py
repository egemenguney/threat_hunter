#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Delta Force Malware Hunter
Automated GitHub malware repository detection tool

Detected Patterns:
- Cyrillic filename obfuscation (Loader.zip with U+043E)
- Suspicious README patterns
- Known malware infrastructure
- Bot-generated repository indicators

Author: Security Research
Date: December 2025
"""

import sys
import os

# Fix Windows console encoding
if sys.platform == 'win32':
    os.system('chcp 65001 > nul 2>&1')
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')

import requests
import re
import json
import csv
import time
import hashlib
from datetime import datetime
from urllib.parse import quote, unquote
from pathlib import Path
from typing import List, Dict, Optional
from dataclasses import dataclass, asdict
import base64

# ============================================================================
# CONFIGURATION
# ============================================================================

# GitHub API (add your Personal Access Token for higher rate limits)
# Set via environment variable: export GITHUB_TOKEN="ghp_xxxx"
GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN", "")
GITHUB_API = "https://api.github.com"

# Rate limiting
REQUEST_DELAY = 2  # seconds between requests (respect GitHub limits)

# Output files
OUTPUT_DIR = Path(".")
RESULTS_JSON = OUTPUT_DIR / "detected_repos.json"
RESULTS_CSV = OUTPUT_DIR / "detected_repos.csv"
REPORT_MD = OUTPUT_DIR / "AUTO_GENERATED_REPORT.md"

# ============================================================================
# DETECTION PATTERNS
# ============================================================================

@dataclass
class DetectionPattern:
    """Pattern definition for malware detection"""
    name: str
    description: str
    severity: str  # HIGH, MEDIUM, LOW
    pattern_type: str  # FILENAME, README, URL, STRUCTURE

# Cyrillic obfuscation detection
CYRILLIC_PATTERNS = {
    # Cyrillic 'о' (U+043E) instead of Latin 'o'
    'о': 'o',  # Most common
    'а': 'a',  # Cyrillic 'а' vs Latin 'a'
    'е': 'e',  # Cyrillic 'е' vs Latin 'e'
    'р': 'p',  # Cyrillic 'р' vs Latin 'p'
    'с': 'c',  # Cyrillic 'с' vs Latin 'c'
    'х': 'x',  # Cyrillic 'х' vs Latin 'x'
}

# Known malicious filenames (with potential Cyrillic)
SUSPICIOUS_FILENAMES = [
    r'L[оo]ader\.zip',      # Loader.zip with Cyrillic о
    r'L[оo]ader\.rar',
    r'Install\.zip',
    r'Setup\.exe',
    r'Hack.*\.zip',
    r'Cheat.*\.zip',
    r'.*\.scr$',            # Screensaver (often malware)
]

# README red flags
README_RED_FLAGS = [
    r'disable.*antivirus',
    r'turn off.*antivirus',
    r'disable.*defender',
    r'disable.*av',
    r'antivirus.*interference',
    r'PASS\s*[-:=]\s*\d+',          # Password hints like "PASS - 1212"
    r'anti[- ]?ban',
    r'undetected',
    r'bypass.*detection',
    r'stealth\s*mode',
    r'GITHUB\s*VERIF[IY]ED',        # Fake verification claims
    r'VirusTotal\s*Certified',      # Fake VT claims
]

# Bot-generated README indicators
BOT_INDICATORS = [
    r'🚀.*🔥.*💥',                   # Excessive emoji combinations
    r'2025.*Edition',
    r'MIT\s*License.*hack',         # MIT License for hacks (nonsensical)
    r'educational.*purposes.*only',
    r'Windows\s*2025',              # Non-existent OS
    r'SEO.*Keywords?:',             # SEO keyword stuffing
]

# Known malicious domains
MALICIOUS_DOMAINS = [
    'kiamatka.com',
    'hanblga.com',
    'cheatseller.ru',
    'get-hacks.xyz',
]

# Known malicious MediaFire folders
MALICIOUS_MEDIAFIRE = [
    'dmaaqrcqphy0d',
    'hyewxkvve9m42',
]

# Search queries for finding malware repos
SEARCH_QUERIES = [
    'delta force hack',
    'delta force cheat',
    'delta force aimbot',
    'delta force loader',
    'filename:Loader.zip delta',
    'filename:Lоader.zip',  # With Cyrillic о
]

# ============================================================================
# DATA STRUCTURES
# ============================================================================

@dataclass
class DetectedRepo:
    """Represents a detected malicious repository"""
    url: str
    owner: str
    repo_name: str
    detection_type: str
    severity: str
    evidence: List[str]
    detected_at: str
    cyrillic_detected: bool = False
    readme_flags: List[str] = None
    files: List[str] = None
    report_status: str = "PENDING"
    
    def __post_init__(self):
        if self.readme_flags is None:
            self.readme_flags = []
        if self.files is None:
            self.files = []

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def get_headers() -> Dict[str, str]:
    """Get API headers with optional authentication"""
    headers = {
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'MalwareHunter/1.0'
    }
    if GITHUB_TOKEN:
        headers['Authorization'] = f'token {GITHUB_TOKEN}'
    return headers

def detect_cyrillic_in_filename(filename: str) -> tuple[bool, str]:
    """
    Detect Cyrillic character obfuscation in filenames
    Returns: (is_cyrillic, details)
    """
    detected_chars = []
    
    for cyrillic, latin in CYRILLIC_PATTERNS.items():
        if cyrillic in filename:
            # Get Unicode codepoint
            codepoint = hex(ord(cyrillic))
            detected_chars.append(f"'{cyrillic}' (U+{ord(cyrillic):04X}) instead of '{latin}'")
    
    if detected_chars:
        return True, f"Cyrillic obfuscation: {', '.join(detected_chars)}"
    return False, ""

def check_url_encoded_cyrillic(url: str) -> tuple[bool, str]:
    """
    Check for URL-encoded Cyrillic characters
    %D0%BE = Cyrillic 'о' (U+043E)
    """
    cyrillic_encodings = {
        '%D0%BE': 'о (U+043E)',  # Cyrillic о
        '%D0%B0': 'а (U+0430)',  # Cyrillic а
        '%D0%B5': 'е (U+0435)',  # Cyrillic е
        '%D1%80': 'р (U+0440)',  # Cyrillic р
        '%D1%81': 'с (U+0441)',  # Cyrillic с
    }
    
    detected = []
    for encoding, char in cyrillic_encodings.items():
        if encoding.upper() in url.upper():
            detected.append(f"{encoding} = {char}")
    
    if detected:
        return True, f"URL-encoded Cyrillic: {', '.join(detected)}"
    return False, ""

def analyze_readme(content: str) -> List[str]:
    """Analyze README content for red flags"""
    flags = []
    content_lower = content.lower()
    
    # Check for red flags
    for pattern in README_RED_FLAGS:
        if re.search(pattern, content, re.IGNORECASE):
            flags.append(f"RED FLAG: {pattern}")
    
    # Check for bot indicators
    for pattern in BOT_INDICATORS:
        if re.search(pattern, content, re.IGNORECASE):
            flags.append(f"BOT INDICATOR: {pattern}")
    
    # Check for malicious domains
    for domain in MALICIOUS_DOMAINS:
        if domain in content_lower:
            flags.append(f"MALICIOUS DOMAIN: {domain}")
    
    # Check for MediaFire links
    for folder_id in MALICIOUS_MEDIAFIRE:
        if folder_id in content_lower:
            flags.append(f"KNOWN MALWARE MEDIAFIRE: {folder_id}")
    
    return flags

def calculate_suspicion_score(repo_data: Dict, files: List[str], readme_content: str) -> int:
    """
    Calculate a suspicion score (0-100) based on various indicators
    """
    score = 0
    
    # Check stars/forks (0 = suspicious for "popular" claims)
    if repo_data.get('stargazers_count', 0) == 0:
        score += 10
    if repo_data.get('forks_count', 0) == 0:
        score += 5
    
    # Check for Cyrillic in files
    for file in files:
        is_cyrillic, _ = detect_cyrillic_in_filename(file)
        if is_cyrillic:
            score += 30
            break
    
    # Check README
    readme_flags = analyze_readme(readme_content)
    score += len(readme_flags) * 10
    
    # Check for suspicious file extensions
    for file in files:
        if re.search(r'\.(exe|dll|scr|bat|cmd|ps1|vbs)$', file, re.IGNORECASE):
            score += 15
            break
    
    # Check account age (if available)
    # New accounts with single repo = suspicious
    
    return min(score, 100)

# ============================================================================
# GITHUB API FUNCTIONS
# ============================================================================

def search_repositories(query: str, max_results: int = 30) -> List[Dict]:
    """Search GitHub for repositories matching query"""
    results = []
    page = 1
    per_page = 30
    
    while len(results) < max_results:
        url = f"{GITHUB_API}/search/repositories"
        params = {
            'q': query,
            'sort': 'updated',
            'order': 'desc',
            'page': page,
            'per_page': per_page
        }
        
        try:
            response = requests.get(url, headers=get_headers(), params=params)
            
            if response.status_code == 403:
                print(f"[!] Rate limited. Waiting 60 seconds...")
                time.sleep(60)
                continue
            
            response.raise_for_status()
            data = response.json()
            
            items = data.get('items', [])
            if not items:
                break
            
            results.extend(items)
            page += 1
            
            # Rate limiting
            time.sleep(REQUEST_DELAY)
            
        except requests.RequestException as e:
            print(f"❌ Error searching: {e}")
            break
    
    return results[:max_results]

def get_repo_contents(owner: str, repo: str) -> List[Dict]:
    """Get repository file listing"""
    url = f"{GITHUB_API}/repos/{owner}/{repo}/contents"
    
    try:
        response = requests.get(url, headers=get_headers())
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"❌ Error getting contents for {owner}/{repo}: {e}")
        return []

def get_readme_content(owner: str, repo: str) -> str:
    """Get README content"""
    url = f"{GITHUB_API}/repos/{owner}/{repo}/readme"
    
    try:
        response = requests.get(url, headers=get_headers())
        response.raise_for_status()
        data = response.json()
        
        # Decode base64 content
        content = data.get('content', '')
        if content:
            return base64.b64decode(content).decode('utf-8', errors='ignore')
    except requests.RequestException:
        pass
    
    return ""

# ============================================================================
# ANALYSIS FUNCTIONS
# ============================================================================

def analyze_repository(repo_data: Dict) -> Optional[DetectedRepo]:
    """
    Analyze a single repository for malicious indicators
    """
    owner = repo_data['owner']['login']
    repo_name = repo_data['name']
    url = repo_data['html_url']
    
    print(f"🔍 Analyzing: {owner}/{repo_name}")
    
    evidence = []
    severity = "LOW"
    cyrillic_detected = False
    readme_flags = []
    detected_files = []
    
    # Get repository contents
    time.sleep(REQUEST_DELAY)
    contents = get_repo_contents(owner, repo_name)
    
    # Check each file for Cyrillic obfuscation
    for item in contents:
        if item['type'] == 'file':
            filename = item['name']
            file_url = item.get('html_url', '')
            
            # Check filename for Cyrillic
            is_cyrillic, cyrillic_details = detect_cyrillic_in_filename(filename)
            if is_cyrillic:
                cyrillic_detected = True
                evidence.append(f"CYRILLIC FILENAME: {filename} - {cyrillic_details}")
                severity = "HIGH"
                detected_files.append(filename)
            
            # Check URL encoding
            is_encoded, encoded_details = check_url_encoded_cyrillic(file_url)
            if is_encoded:
                cyrillic_detected = True
                evidence.append(f"URL ENCODED CYRILLIC: {encoded_details}")
                severity = "HIGH"
    
    # Get and analyze README
    time.sleep(REQUEST_DELAY)
    readme_content = get_readme_content(owner, repo_name)
    
    if readme_content:
        readme_flags = analyze_readme(readme_content)
        for flag in readme_flags:
            evidence.append(flag)
            if "MALICIOUS DOMAIN" in flag or "disable.*antivirus" in flag.lower():
                severity = "HIGH"
            elif severity != "HIGH":
                severity = "MEDIUM"
    
    # Calculate overall suspicion score
    score = calculate_suspicion_score(repo_data, detected_files, readme_content)
    
    # Only return if suspicious enough
    if score >= 20 or cyrillic_detected:
        evidence.append(f"SUSPICION SCORE: {score}/100")
        
        return DetectedRepo(
            url=url,
            owner=owner,
            repo_name=repo_name,
            detection_type="CYRILLIC_OBFUSCATION" if cyrillic_detected else "PATTERN_MATCH",
            severity=severity,
            evidence=evidence,
            detected_at=datetime.now().isoformat(),
            cyrillic_detected=cyrillic_detected,
            readme_flags=readme_flags,
            files=detected_files
        )
    
    return None

# ============================================================================
# REPORTING FUNCTIONS
# ============================================================================

def save_results_json(detected: List[DetectedRepo]):
    """Save results to JSON file"""
    data = [asdict(d) for d in detected]
    with open(RESULTS_JSON, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    print(f"📁 Saved to {RESULTS_JSON}")

def save_results_csv(detected: List[DetectedRepo]):
    """Save results to CSV file"""
    if not detected:
        return
    
    with open(RESULTS_CSV, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(['URL', 'Owner', 'Repo', 'Severity', 'Detection Type', 
                        'Cyrillic', 'Evidence Count', 'Status', 'Detected At'])
        
        for d in detected:
            writer.writerow([
                d.url, d.owner, d.repo_name, d.severity, d.detection_type,
                d.cyrillic_detected, len(d.evidence), d.report_status, d.detected_at
            ])
    
    print(f"📁 Saved to {RESULTS_CSV}")

def generate_markdown_report(detected: List[DetectedRepo]):
    """Generate comprehensive Markdown report"""
    
    # Count statistics
    total = len(detected)
    high_severity = len([d for d in detected if d.severity == "HIGH"])
    cyrillic_count = len([d for d in detected if d.cyrillic_detected])
    
    report = f"""# 🚨 AUTOMATED MALWARE DETECTION REPORT

**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}  
**Tool:** Delta Force Malware Hunter v1.0

---

## 📊 SUMMARY

| Metric | Count |
|--------|-------|
| Total Detected | {total} |
| HIGH Severity | {high_severity} |
| Cyrillic Obfuscation | {cyrillic_count} |

---

## 🔴 DETECTED REPOSITORIES

"""
    
    # Group by severity
    for severity in ["HIGH", "MEDIUM", "LOW"]:
        repos = [d for d in detected if d.severity == severity]
        if repos:
            emoji = "🔴" if severity == "HIGH" else "🟠" if severity == "MEDIUM" else "🟡"
            report += f"### {emoji} {severity} SEVERITY ({len(repos)})\n\n"
            
            for d in repos:
                report += f"""#### [{d.owner}/{d.repo_name}]({d.url})

| Field | Value |
|-------|-------|
| Detection Type | {d.detection_type} |
| Cyrillic | {'✅ YES' if d.cyrillic_detected else '❌ No'} |
| Detected At | {d.detected_at} |
| Status | {d.report_status} |

**Evidence:**
"""
                for e in d.evidence:
                    report += f"- {e}\n"
                
                report += "\n---\n\n"
    
    # Add report template
    report += """
## 📝 GITHUB REPORT TEMPLATE

```
## MALWARE DISTRIBUTION - AUTOMATED DETECTION

This repository was detected by automated malware scanning tools.

### Detection Method
- Cyrillic filename obfuscation (Unicode homoglyphs)
- Pattern matching against known malware indicators
- README analysis for social engineering tactics

### Evidence
[INSERT EVIDENCE FROM ABOVE]

### Request
1. Remove repository immediately
2. Ban associated account
3. Flag pattern for future detection

### Related Campaign
Part of coordinated "Delta Force hack" malware distribution network.
```

---

*Report generated automatically by Delta Force Malware Hunter*
"""
    
    with open(REPORT_MD, 'w', encoding='utf-8') as f:
        f.write(report)
    
    print(f"📁 Saved to {REPORT_MD}")

# ============================================================================
# MAIN EXECUTION
# ============================================================================

def run_scan(queries: List[str] = None, max_per_query: int = 20):
    """Run the malware detection scan"""
    
    print("""
+====================================================================+
|  [*] DELTA FORCE MALWARE HUNTER                                   |
|  Automated GitHub Malware Repository Detection                     |
+====================================================================+
    """)
    
    if queries is None:
        queries = SEARCH_QUERIES
    
    all_detected: List[DetectedRepo] = []
    seen_repos = set()
    
    for query in queries:
        print(f"\n🔎 Searching: '{query}'")
        repos = search_repositories(query, max_per_query)
        print(f"   Found {len(repos)} repositories")
        
        for repo_data in repos:
            repo_id = repo_data['id']
            
            # Skip duplicates
            if repo_id in seen_repos:
                continue
            seen_repos.add(repo_id)
            
            # Analyze repository
            detection = analyze_repository(repo_data)
            
            if detection:
                all_detected.append(detection)
                severity_emoji = "🔴" if detection.severity == "HIGH" else "🟠" if detection.severity == "MEDIUM" else "🟡"
                print(f"   {severity_emoji} DETECTED: {detection.owner}/{detection.repo_name}")
    
    # Generate reports
    print(f"\n{'='*60}")
    print(f"📊 SCAN COMPLETE")
    print(f"   Total repositories analyzed: {len(seen_repos)}")
    print(f"   Malicious repositories detected: {len(all_detected)}")
    print(f"{'='*60}\n")
    
    if all_detected:
        save_results_json(all_detected)
        save_results_csv(all_detected)
        generate_markdown_report(all_detected)
    
    return all_detected

def quick_check_repo(repo_url: str) -> Optional[DetectedRepo]:
    """Quick check a single repository URL"""
    
    # Parse URL
    match = re.match(r'https?://github\.com/([^/]+)/([^/]+)', repo_url)
    if not match:
        print(f"❌ Invalid GitHub URL: {repo_url}")
        return None
    
    owner, repo = match.groups()
    
    # Get repo data
    url = f"{GITHUB_API}/repos/{owner}/{repo}"
    try:
        response = requests.get(url, headers=get_headers())
        response.raise_for_status()
        repo_data = response.json()
    except requests.RequestException as e:
        print(f"❌ Error fetching repo: {e}")
        return None
    
    return analyze_repository(repo_data)

# ============================================================================
# CLI
# ============================================================================

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1:
        # Quick check single repo
        repo_url = sys.argv[1]
        print(f"🔍 Quick checking: {repo_url}\n")
        result = quick_check_repo(repo_url)
        
        if result:
            print(f"\n🚨 MALICIOUS REPOSITORY DETECTED!")
            print(f"   Severity: {result.severity}")
            print(f"   Type: {result.detection_type}")
            print(f"   Cyrillic: {result.cyrillic_detected}")
            print(f"\n   Evidence:")
            for e in result.evidence:
                print(f"   - {e}")
        else:
            print("✅ No obvious malicious indicators detected")
    else:
        # Run full scan
        run_scan()


